//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

         
// USER INCLUDES			
#include <SI_EFM8BB3_Register_Enums.h>

//-----------------------------------------------------------------------------
// Global VARIABLES
//-----------------------------------------------------------------------------
int LEDCOUNT = 0; //used to set some frequency in a "hacky" manner, resets at maxLen
int maxLen=10; //Highest LEDCOUNT can reach
//00: and 11: clear 10: or 01: add
int commands[2][6]={  //opcode, opcode, digit, digit, digit, digit
		   {1,1,0,0,0,0}, //this resets the ALU
		   {0,1,1,1,1,1} //This subtracts one
};

int PC		=	0;
//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN::TF2L (Timer # Low Byte Overflow Flag)
//
// This routine changes the state of the LED whenever Timer2 overflows.
//
//-----------------------------------------------------------------------------


SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn) //This is the interrupt for the timer, code here is run on every clock cycle.
{
	TMR2CN0_TF2H = 0;                  // Clear Timer2 interrupt flag
	if (LEDCOUNT==0){ //This emulates frequency
		P0_B7=0; //This is the clock pin
		if (PC<=16 && PC>0){ //subtracting occurs most of the time
			P0_B0=commands[1][0]; //first digit of opcode
		    P0_B1=commands[1][1]; //second digit of opcode
			P0_B2=commands[1][2]; //first digit of number
		    P0_B3=commands[1][3]; //second digit
		    P0_B4=commands[1][4]; //third digit
			P0_B6=commands[1][5]; //fourth digit
			PC++; //counts up steps
		}
		else { //this is where resetting occurs
			P0_B0=commands[0][0]; //first digit of opcode
		    P0_B1=commands[0][1]; //2nd
			P0_B2=commands[0][2]; //first digit of number
		    P0_B3=commands[0][3]; //2nd
		    P0_B4=commands[0][4]; //3rd
			P0_B6=commands[0][5]; //4th
			PC++; //counts up steps
		}
	}
	else if (LEDCOUNT==maxLen/2){
		P0_B7=1; //Clock pin
	}

	if (LEDCOUNT>maxLen){
		LEDCOUNT=0; //resets at max "frequency"
	}
	else {
		LEDCOUNT++; //continues onwards in terms of "frequency"
	}
}


